{"ast":null,"code":"// history\n(function (window, factory) {\n  // universal module definition\n  if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, require('./core'), require('fizzy-ui-utils'));\n  } else {\n    // browser global\n    factory(window, window.InfiniteScroll, window.fizzyUIUtils);\n  }\n})(window, function factory(window, InfiniteScroll, utils) {\n  let proto = InfiniteScroll.prototype;\n  Object.assign(InfiniteScroll.defaults, {\n    history: 'replace'\n    // historyTitle: false,\n  });\n\n  let link = document.createElement('a');\n\n  // ----- create/destroy ----- //\n\n  InfiniteScroll.create.history = function () {\n    if (!this.options.history) return;\n\n    // check for same origin\n    link.href = this.getAbsolutePath();\n    // MS Edge does not have origin on link\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12236493/\n    let linkOrigin = link.origin || link.protocol + '//' + link.host;\n    let isSameOrigin = linkOrigin == location.origin;\n    if (!isSameOrigin) {\n      console.error('[InfiniteScroll] cannot set history with different origin: ' + `${link.origin} on ${location.origin} . History behavior disabled.`);\n      return;\n    }\n\n    // two ways to handle changing history\n    if (this.options.append) {\n      this.createHistoryAppend();\n    } else {\n      this.createHistoryPageLoad();\n    }\n  };\n  proto.createHistoryAppend = function () {\n    this.updateMeasurements();\n    this.updateScroller();\n    // array of scroll positions of appended pages\n    this.scrollPages = [\n    // first page\n    {\n      top: 0,\n      path: location.href,\n      title: document.title\n    }];\n    this.scrollPage = this.scrollPages[0];\n    // events\n    this.scrollHistoryHandler = this.onScrollHistory.bind(this);\n    this.unloadHandler = this.onUnload.bind(this);\n    this.scroller.addEventListener('scroll', this.scrollHistoryHandler);\n    this.on('append', this.onAppendHistory);\n    this.bindHistoryAppendEvents(true);\n  };\n  proto.bindHistoryAppendEvents = function (isBind) {\n    let addRemove = isBind ? 'addEventListener' : 'removeEventListener';\n    this.scroller[addRemove]('scroll', this.scrollHistoryHandler);\n    window[addRemove]('unload', this.unloadHandler);\n  };\n  proto.createHistoryPageLoad = function () {\n    this.on('load', this.onPageLoadHistory);\n  };\n  InfiniteScroll.destroy.history = proto.destroyHistory = function () {\n    let isHistoryAppend = this.options.history && this.options.append;\n    if (isHistoryAppend) {\n      this.bindHistoryAppendEvents(false);\n    }\n  };\n\n  // ----- append history ----- //\n\n  proto.onAppendHistory = function (response, path, items) {\n    // do not proceed if no items. #779\n    if (!items || !items.length) return;\n    let firstItem = items[0];\n    let elemScrollY = this.getElementScrollY(firstItem);\n    // resolve path\n    link.href = path;\n    // add page data to hash\n    this.scrollPages.push({\n      top: elemScrollY,\n      path: link.href,\n      title: response.title\n    });\n  };\n  proto.getElementScrollY = function (elem) {\n    if (this.options.elementScroll) {\n      return elem.offsetTop - this.top;\n    } else {\n      let rect = elem.getBoundingClientRect();\n      return rect.top + window.scrollY;\n    }\n  };\n  proto.onScrollHistory = function () {\n    // cycle through positions, find biggest without going over\n    let scrollPage = this.getClosestScrollPage();\n    // set history if changed\n    if (scrollPage != this.scrollPage) {\n      this.scrollPage = scrollPage;\n      this.setHistory(scrollPage.title, scrollPage.path);\n    }\n  };\n  utils.debounceMethod(InfiniteScroll, 'onScrollHistory', 150);\n  proto.getClosestScrollPage = function () {\n    let scrollViewY;\n    if (this.options.elementScroll) {\n      scrollViewY = this.scroller.scrollTop + this.scroller.clientHeight / 2;\n    } else {\n      scrollViewY = window.scrollY + this.windowHeight / 2;\n    }\n    let scrollPage;\n    for (let page of this.scrollPages) {\n      if (page.top >= scrollViewY) break;\n      scrollPage = page;\n    }\n    return scrollPage;\n  };\n  proto.setHistory = function (title, path) {\n    let optHistory = this.options.history;\n    let historyMethod = optHistory && history[optHistory + 'State'];\n    if (!historyMethod) return;\n    history[optHistory + 'State'](null, title, path);\n    if (this.options.historyTitle) document.title = title;\n    this.dispatchEvent('history', null, [title, path]);\n  };\n\n  // scroll to top to prevent initial scroll-reset after page refresh\n  // https://stackoverflow.com/a/18633915/182183\n  proto.onUnload = function () {\n    if (this.scrollPage.top === 0) return;\n\n    // calculate where scroll position would be on refresh\n    let scrollY = window.scrollY - this.scrollPage.top + this.top;\n    // disable scroll event before setting scroll #679\n    this.destroyHistory();\n    scrollTo(0, scrollY);\n  };\n\n  // ----- load history ----- //\n\n  // update URL\n  proto.onPageLoadHistory = function (response, path) {\n    this.setHistory(response.title, path);\n  };\n\n  // --------------------------  -------------------------- //\n\n  return InfiniteScroll;\n});","map":{"version":3,"names":["window","factory","module","exports","require","InfiniteScroll","fizzyUIUtils","utils","proto","prototype","Object","assign","defaults","history","link","document","createElement","create","options","href","getAbsolutePath","linkOrigin","origin","protocol","host","isSameOrigin","location","console","error","append","createHistoryAppend","createHistoryPageLoad","updateMeasurements","updateScroller","scrollPages","top","path","title","scrollPage","scrollHistoryHandler","onScrollHistory","bind","unloadHandler","onUnload","scroller","addEventListener","on","onAppendHistory","bindHistoryAppendEvents","isBind","addRemove","onPageLoadHistory","destroy","destroyHistory","isHistoryAppend","response","items","length","firstItem","elemScrollY","getElementScrollY","push","elem","elementScroll","offsetTop","rect","getBoundingClientRect","scrollY","getClosestScrollPage","setHistory","debounceMethod","scrollViewY","scrollTop","clientHeight","windowHeight","page","optHistory","historyMethod","historyTitle","dispatchEvent","scrollTo"],"sources":["/Users/michaelofengenden/Desktop/Infapp/node_modules/infinite-scroll/js/history.js"],"sourcesContent":["// history\n( function( window, factory ) {\n  // universal module definition\n  if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n        window,\n        require('./core'),\n        require('fizzy-ui-utils'),\n    );\n  } else {\n    // browser global\n    factory(\n        window,\n        window.InfiniteScroll,\n        window.fizzyUIUtils,\n    );\n  }\n\n}( window, function factory( window, InfiniteScroll, utils ) {\n\nlet proto = InfiniteScroll.prototype;\n\nObject.assign( InfiniteScroll.defaults, {\n  history: 'replace',\n  // historyTitle: false,\n} );\n\nlet link = document.createElement('a');\n\n// ----- create/destroy ----- //\n\nInfiniteScroll.create.history = function() {\n  if ( !this.options.history ) return;\n\n  // check for same origin\n  link.href = this.getAbsolutePath();\n  // MS Edge does not have origin on link\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12236493/\n  let linkOrigin = link.origin || link.protocol + '//' + link.host;\n  let isSameOrigin = linkOrigin == location.origin;\n  if ( !isSameOrigin ) {\n    console.error( '[InfiniteScroll] cannot set history with different origin: ' +\n      `${link.origin} on ${location.origin} . History behavior disabled.` );\n    return;\n  }\n\n  // two ways to handle changing history\n  if ( this.options.append ) {\n    this.createHistoryAppend();\n  } else {\n    this.createHistoryPageLoad();\n  }\n};\n\nproto.createHistoryAppend = function() {\n  this.updateMeasurements();\n  this.updateScroller();\n  // array of scroll positions of appended pages\n  this.scrollPages = [\n    // first page\n    {\n      top: 0,\n      path: location.href,\n      title: document.title,\n    },\n  ];\n  this.scrollPage = this.scrollPages[0];\n  // events\n  this.scrollHistoryHandler = this.onScrollHistory.bind( this );\n  this.unloadHandler = this.onUnload.bind( this );\n  this.scroller.addEventListener( 'scroll', this.scrollHistoryHandler );\n  this.on( 'append', this.onAppendHistory );\n  this.bindHistoryAppendEvents( true );\n};\n\nproto.bindHistoryAppendEvents = function( isBind ) {\n  let addRemove = isBind ? 'addEventListener' : 'removeEventListener';\n  this.scroller[ addRemove ]( 'scroll', this.scrollHistoryHandler );\n  window[ addRemove ]( 'unload', this.unloadHandler );\n};\n\nproto.createHistoryPageLoad = function() {\n  this.on( 'load', this.onPageLoadHistory );\n};\n\nInfiniteScroll.destroy.history =\nproto.destroyHistory = function() {\n  let isHistoryAppend = this.options.history && this.options.append;\n  if ( isHistoryAppend ) {\n    this.bindHistoryAppendEvents( false );\n  }\n};\n\n// ----- append history ----- //\n\nproto.onAppendHistory = function( response, path, items ) {\n  // do not proceed if no items. #779\n  if ( !items || !items.length ) return;\n\n  let firstItem = items[0];\n  let elemScrollY = this.getElementScrollY( firstItem );\n  // resolve path\n  link.href = path;\n  // add page data to hash\n  this.scrollPages.push({\n    top: elemScrollY,\n    path: link.href,\n    title: response.title,\n  });\n};\n\nproto.getElementScrollY = function( elem ) {\n  if ( this.options.elementScroll ) {\n    return elem.offsetTop - this.top;\n  } else {\n    let rect = elem.getBoundingClientRect();\n    return rect.top + window.scrollY;\n  }\n};\n\nproto.onScrollHistory = function() {\n  // cycle through positions, find biggest without going over\n  let scrollPage = this.getClosestScrollPage();\n  // set history if changed\n  if ( scrollPage != this.scrollPage ) {\n    this.scrollPage = scrollPage;\n    this.setHistory( scrollPage.title, scrollPage.path );\n  }\n};\n\nutils.debounceMethod( InfiniteScroll, 'onScrollHistory', 150 );\n\nproto.getClosestScrollPage = function() {\n  let scrollViewY;\n  if ( this.options.elementScroll ) {\n    scrollViewY = this.scroller.scrollTop + this.scroller.clientHeight / 2;\n  } else {\n    scrollViewY = window.scrollY + this.windowHeight / 2;\n  }\n\n  let scrollPage;\n  for ( let page of this.scrollPages ) {\n    if ( page.top >= scrollViewY ) break;\n\n    scrollPage = page;\n  }\n  return scrollPage;\n};\n\nproto.setHistory = function( title, path ) {\n  let optHistory = this.options.history;\n  let historyMethod = optHistory && history[ optHistory + 'State' ];\n  if ( !historyMethod ) return;\n\n  history[ optHistory + 'State' ]( null, title, path );\n  if ( this.options.historyTitle ) document.title = title;\n  this.dispatchEvent( 'history', null, [ title, path ] );\n};\n\n// scroll to top to prevent initial scroll-reset after page refresh\n// https://stackoverflow.com/a/18633915/182183\nproto.onUnload = function() {\n  if ( this.scrollPage.top === 0 ) return;\n\n  // calculate where scroll position would be on refresh\n  let scrollY = window.scrollY - this.scrollPage.top + this.top;\n  // disable scroll event before setting scroll #679\n  this.destroyHistory();\n  scrollTo( 0, scrollY );\n};\n\n// ----- load history ----- //\n\n// update URL\nproto.onPageLoadHistory = function( response, path ) {\n  this.setHistory( response.title, path );\n};\n\n// --------------------------  -------------------------- //\n\nreturn InfiniteScroll;\n\n} ) );\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}