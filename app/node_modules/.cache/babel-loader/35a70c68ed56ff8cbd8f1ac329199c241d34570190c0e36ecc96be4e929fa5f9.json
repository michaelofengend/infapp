{"ast":null,"code":"// page-load\n(function (window, factory) {\n  // universal module definition\n  if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, require('./core'));\n  } else {\n    // browser global\n    factory(window, window.InfiniteScroll);\n  }\n})(window, function factory(window, InfiniteScroll) {\n  let proto = InfiniteScroll.prototype;\n  Object.assign(InfiniteScroll.defaults, {\n    // append: false,\n    loadOnScroll: true,\n    checkLastPage: true,\n    responseBody: 'text',\n    domParseResponse: true\n    // prefill: false,\n    // outlayer: null,\n  });\n\n  InfiniteScroll.create.pageLoad = function () {\n    this.canLoad = true;\n    this.on('scrollThreshold', this.onScrollThresholdLoad);\n    this.on('load', this.checkLastPage);\n    if (this.options.outlayer) {\n      this.on('append', this.onAppendOutlayer);\n    }\n  };\n  proto.onScrollThresholdLoad = function () {\n    if (this.options.loadOnScroll) this.loadNextPage();\n  };\n  let domParser = new DOMParser();\n  proto.loadNextPage = function () {\n    if (this.isLoading || !this.canLoad) return;\n    let {\n      responseBody,\n      domParseResponse,\n      fetchOptions\n    } = this.options;\n    let path = this.getAbsolutePath();\n    this.isLoading = true;\n    if (typeof fetchOptions == 'function') fetchOptions = fetchOptions();\n    let fetchPromise = fetch(path, fetchOptions).then(response => {\n      if (!response.ok) {\n        let error = new Error(response.statusText);\n        this.onPageError(error, path, response);\n        return {\n          response\n        };\n      }\n      return response[responseBody]().then(body => {\n        let canDomParse = responseBody == 'text' && domParseResponse;\n        if (canDomParse) {\n          body = domParser.parseFromString(body, 'text/html');\n        }\n        if (response.status == 204) {\n          this.lastPageReached(body, path);\n          return {\n            body,\n            response\n          };\n        } else {\n          return this.onPageLoad(body, path, response);\n        }\n      });\n    }).catch(error => {\n      this.onPageError(error, path);\n    });\n    this.dispatchEvent('request', null, [path, fetchPromise]);\n    return fetchPromise;\n  };\n  proto.onPageLoad = function (body, path, response) {\n    // done loading if not appending\n    if (!this.options.append) {\n      this.isLoading = false;\n    }\n    this.pageIndex++;\n    this.loadCount++;\n    this.dispatchEvent('load', null, [body, path, response]);\n    return this.appendNextPage(body, path, response);\n  };\n  proto.appendNextPage = function (body, path, response) {\n    let {\n      append,\n      responseBody,\n      domParseResponse\n    } = this.options;\n    // do not append json\n    let isDocument = responseBody == 'text' && domParseResponse;\n    if (!isDocument || !append) return {\n      body,\n      response\n    };\n    let items = body.querySelectorAll(append);\n    let promiseValue = {\n      body,\n      response,\n      items\n    };\n    // last page hit if no items. #840\n    if (!items || !items.length) {\n      this.lastPageReached(body, path);\n      return promiseValue;\n    }\n    let fragment = getItemsFragment(items);\n    let appendReady = () => {\n      this.appendItems(items, fragment);\n      this.isLoading = false;\n      this.dispatchEvent('append', null, [body, path, items, response]);\n      return promiseValue;\n    };\n\n    // TODO add hook for option to trigger appendReady\n    if (this.options.outlayer) {\n      return this.appendOutlayerItems(fragment, appendReady);\n    } else {\n      return appendReady();\n    }\n  };\n  proto.appendItems = function (items, fragment) {\n    if (!items || !items.length) return;\n\n    // get fragment if not provided\n    fragment = fragment || getItemsFragment(items);\n    refreshScripts(fragment);\n    this.element.appendChild(fragment);\n  };\n  function getItemsFragment(items) {\n    // add items to fragment\n    let fragment = document.createDocumentFragment();\n    if (items) fragment.append(...items);\n    return fragment;\n  }\n\n  // replace <script>s with copies so they load\n  // <script>s added by InfiniteScroll will not load\n  // similar to https://stackoverflow.com/questions/610995\n  function refreshScripts(fragment) {\n    let scripts = fragment.querySelectorAll('script');\n    for (let script of scripts) {\n      let freshScript = document.createElement('script');\n      // copy attributes\n      let attrs = script.attributes;\n      for (let attr of attrs) {\n        freshScript.setAttribute(attr.name, attr.value);\n      }\n      // copy inner script code. #718, #782\n      freshScript.innerHTML = script.innerHTML;\n      script.parentNode.replaceChild(freshScript, script);\n    }\n  }\n\n  // ----- outlayer ----- //\n\n  proto.appendOutlayerItems = function (fragment, appendReady) {\n    let imagesLoaded = InfiniteScroll.imagesLoaded || window.imagesLoaded;\n    if (!imagesLoaded) {\n      console.error('[InfiniteScroll] imagesLoaded required for outlayer option');\n      this.isLoading = false;\n      return;\n    }\n    // append once images loaded\n    return new Promise(function (resolve) {\n      imagesLoaded(fragment, function () {\n        let bodyResponse = appendReady();\n        resolve(bodyResponse);\n      });\n    });\n  };\n  proto.onAppendOutlayer = function (response, path, items) {\n    this.options.outlayer.appended(items);\n  };\n\n  // ----- checkLastPage ----- //\n\n  // check response for next element\n  proto.checkLastPage = function (body, path) {\n    let {\n      checkLastPage,\n      path: pathOpt\n    } = this.options;\n    if (!checkLastPage) return;\n\n    // if path is function, check if next path is truthy\n    if (typeof pathOpt == 'function') {\n      let nextPath = this.getPath();\n      if (!nextPath) {\n        this.lastPageReached(body, path);\n        return;\n      }\n    }\n    // get selector from checkLastPage or path option\n    let selector;\n    if (typeof checkLastPage == 'string') {\n      selector = checkLastPage;\n    } else if (this.isPathSelector) {\n      // path option is selector string\n      selector = pathOpt;\n    }\n    // check last page for selector\n    // bail if no selector or not document response\n    if (!selector || !body.querySelector) return;\n\n    // check if response has selector\n    let nextElem = body.querySelector(selector);\n    if (!nextElem) this.lastPageReached(body, path);\n  };\n  proto.lastPageReached = function (body, path) {\n    this.canLoad = false;\n    this.dispatchEvent('last', null, [body, path]);\n  };\n\n  // ----- error ----- //\n\n  proto.onPageError = function (error, path, response) {\n    this.isLoading = false;\n    this.canLoad = false;\n    this.dispatchEvent('error', null, [error, path, response]);\n    return error;\n  };\n\n  // -------------------------- prefill -------------------------- //\n\n  InfiniteScroll.create.prefill = function () {\n    if (!this.options.prefill) return;\n    let append = this.options.append;\n    if (!append) {\n      console.error(`append option required for prefill. Set as :${append}`);\n      return;\n    }\n    this.updateMeasurements();\n    this.updateScroller();\n    this.isPrefilling = true;\n    this.on('append', this.prefill);\n    this.once('error', this.stopPrefill);\n    this.once('last', this.stopPrefill);\n    this.prefill();\n  };\n  proto.prefill = function () {\n    let distance = this.getPrefillDistance();\n    this.isPrefilling = distance >= 0;\n    if (this.isPrefilling) {\n      this.log('prefill');\n      this.loadNextPage();\n    } else {\n      this.stopPrefill();\n    }\n  };\n  proto.getPrefillDistance = function () {\n    // element scroll\n    if (this.options.elementScroll) {\n      return this.scroller.clientHeight - this.scroller.scrollHeight;\n    }\n    // window\n    return this.windowHeight - this.element.clientHeight;\n  };\n  proto.stopPrefill = function () {\n    this.log('stopPrefill');\n    this.off('append', this.prefill);\n  };\n\n  // --------------------------  -------------------------- //\n\n  return InfiniteScroll;\n});","map":{"version":3,"names":["window","factory","module","exports","require","InfiniteScroll","proto","prototype","Object","assign","defaults","loadOnScroll","checkLastPage","responseBody","domParseResponse","create","pageLoad","canLoad","on","onScrollThresholdLoad","options","outlayer","onAppendOutlayer","loadNextPage","domParser","DOMParser","isLoading","fetchOptions","path","getAbsolutePath","fetchPromise","fetch","then","response","ok","error","Error","statusText","onPageError","body","canDomParse","parseFromString","status","lastPageReached","onPageLoad","catch","dispatchEvent","append","pageIndex","loadCount","appendNextPage","isDocument","items","querySelectorAll","promiseValue","length","fragment","getItemsFragment","appendReady","appendItems","appendOutlayerItems","refreshScripts","element","appendChild","document","createDocumentFragment","scripts","script","freshScript","createElement","attrs","attributes","attr","setAttribute","name","value","innerHTML","parentNode","replaceChild","imagesLoaded","console","Promise","resolve","bodyResponse","appended","pathOpt","nextPath","getPath","selector","isPathSelector","querySelector","nextElem","prefill","updateMeasurements","updateScroller","isPrefilling","once","stopPrefill","distance","getPrefillDistance","log","elementScroll","scroller","clientHeight","scrollHeight","windowHeight","off"],"sources":["/Users/michaelofengenden/Desktop/Infapp/node_modules/infinite-scroll/js/page-load.js"],"sourcesContent":["// page-load\n( function( window, factory ) {\n  // universal module definition\n  if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n        window,\n        require('./core'),\n    );\n  } else {\n    // browser global\n    factory(\n        window,\n        window.InfiniteScroll,\n    );\n  }\n\n}( window, function factory( window, InfiniteScroll ) {\n\nlet proto = InfiniteScroll.prototype;\n\nObject.assign( InfiniteScroll.defaults, {\n  // append: false,\n  loadOnScroll: true,\n  checkLastPage: true,\n  responseBody: 'text',\n  domParseResponse: true,\n  // prefill: false,\n  // outlayer: null,\n} );\n\nInfiniteScroll.create.pageLoad = function() {\n  this.canLoad = true;\n  this.on( 'scrollThreshold', this.onScrollThresholdLoad );\n  this.on( 'load', this.checkLastPage );\n  if ( this.options.outlayer ) {\n    this.on( 'append', this.onAppendOutlayer );\n  }\n};\n\nproto.onScrollThresholdLoad = function() {\n  if ( this.options.loadOnScroll ) this.loadNextPage();\n};\n\nlet domParser = new DOMParser();\n\nproto.loadNextPage = function() {\n  if ( this.isLoading || !this.canLoad ) return;\n\n  let { responseBody, domParseResponse, fetchOptions } = this.options;\n  let path = this.getAbsolutePath();\n  this.isLoading = true;\n  if ( typeof fetchOptions == 'function' ) fetchOptions = fetchOptions();\n\n  let fetchPromise = fetch( path, fetchOptions )\n    .then( ( response ) => {\n      if ( !response.ok ) {\n        let error = new Error( response.statusText );\n        this.onPageError( error, path, response );\n        return { response };\n      }\n\n      return response[ responseBody ]().then( ( body ) => {\n        let canDomParse = responseBody == 'text' && domParseResponse;\n        if ( canDomParse ) {\n          body = domParser.parseFromString( body, 'text/html' );\n        }\n        if ( response.status == 204 ) {\n          this.lastPageReached( body, path );\n          return { body, response };\n        } else {\n          return this.onPageLoad( body, path, response );\n        }\n      } );\n    } )\n    .catch( ( error ) => {\n      this.onPageError( error, path );\n    } );\n\n  this.dispatchEvent( 'request', null, [ path, fetchPromise ] );\n\n  return fetchPromise;\n};\n\nproto.onPageLoad = function( body, path, response ) {\n  // done loading if not appending\n  if ( !this.options.append ) {\n    this.isLoading = false;\n  }\n  this.pageIndex++;\n  this.loadCount++;\n  this.dispatchEvent( 'load', null, [ body, path, response ] );\n  return this.appendNextPage( body, path, response );\n};\n\nproto.appendNextPage = function( body, path, response ) {\n  let { append, responseBody, domParseResponse } = this.options;\n  // do not append json\n  let isDocument = responseBody == 'text' && domParseResponse;\n  if ( !isDocument || !append ) return { body, response };\n\n  let items = body.querySelectorAll( append );\n  let promiseValue = { body, response, items };\n  // last page hit if no items. #840\n  if ( !items || !items.length ) {\n    this.lastPageReached( body, path );\n    return promiseValue;\n  }\n\n  let fragment = getItemsFragment( items );\n  let appendReady = () => {\n    this.appendItems( items, fragment );\n    this.isLoading = false;\n    this.dispatchEvent( 'append', null, [ body, path, items, response ] );\n    return promiseValue;\n  };\n\n  // TODO add hook for option to trigger appendReady\n  if ( this.options.outlayer ) {\n    return this.appendOutlayerItems( fragment, appendReady );\n  } else {\n    return appendReady();\n  }\n};\n\nproto.appendItems = function( items, fragment ) {\n  if ( !items || !items.length ) return;\n\n  // get fragment if not provided\n  fragment = fragment || getItemsFragment( items );\n  refreshScripts( fragment );\n  this.element.appendChild( fragment );\n};\n\nfunction getItemsFragment( items ) {\n  // add items to fragment\n  let fragment = document.createDocumentFragment();\n  if ( items ) fragment.append( ...items );\n  return fragment;\n}\n\n// replace <script>s with copies so they load\n// <script>s added by InfiniteScroll will not load\n// similar to https://stackoverflow.com/questions/610995\nfunction refreshScripts( fragment ) {\n  let scripts = fragment.querySelectorAll('script');\n  for ( let script of scripts ) {\n    let freshScript = document.createElement('script');\n    // copy attributes\n    let attrs = script.attributes;\n    for ( let attr of attrs ) {\n      freshScript.setAttribute( attr.name, attr.value );\n    }\n    // copy inner script code. #718, #782\n    freshScript.innerHTML = script.innerHTML;\n    script.parentNode.replaceChild( freshScript, script );\n  }\n}\n\n// ----- outlayer ----- //\n\nproto.appendOutlayerItems = function( fragment, appendReady ) {\n  let imagesLoaded = InfiniteScroll.imagesLoaded || window.imagesLoaded;\n  if ( !imagesLoaded ) {\n    console.error('[InfiniteScroll] imagesLoaded required for outlayer option');\n    this.isLoading = false;\n    return;\n  }\n  // append once images loaded\n  return new Promise( function( resolve ) {\n    imagesLoaded( fragment, function() {\n      let bodyResponse = appendReady();\n      resolve( bodyResponse );\n    } );\n  } );\n};\n\nproto.onAppendOutlayer = function( response, path, items ) {\n  this.options.outlayer.appended( items );\n};\n\n// ----- checkLastPage ----- //\n\n// check response for next element\nproto.checkLastPage = function( body, path ) {\n  let { checkLastPage, path: pathOpt } = this.options;\n  if ( !checkLastPage ) return;\n\n  // if path is function, check if next path is truthy\n  if ( typeof pathOpt == 'function' ) {\n    let nextPath = this.getPath();\n    if ( !nextPath ) {\n      this.lastPageReached( body, path );\n      return;\n    }\n  }\n  // get selector from checkLastPage or path option\n  let selector;\n  if ( typeof checkLastPage == 'string' ) {\n    selector = checkLastPage;\n  } else if ( this.isPathSelector ) {\n    // path option is selector string\n    selector = pathOpt;\n  }\n  // check last page for selector\n  // bail if no selector or not document response\n  if ( !selector || !body.querySelector ) return;\n\n  // check if response has selector\n  let nextElem = body.querySelector( selector );\n  if ( !nextElem ) this.lastPageReached( body, path );\n};\n\nproto.lastPageReached = function( body, path ) {\n  this.canLoad = false;\n  this.dispatchEvent( 'last', null, [ body, path ] );\n};\n\n// ----- error ----- //\n\nproto.onPageError = function( error, path, response ) {\n  this.isLoading = false;\n  this.canLoad = false;\n  this.dispatchEvent( 'error', null, [ error, path, response ] );\n  return error;\n};\n\n// -------------------------- prefill -------------------------- //\n\nInfiniteScroll.create.prefill = function() {\n  if ( !this.options.prefill ) return;\n\n  let append = this.options.append;\n  if ( !append ) {\n    console.error(`append option required for prefill. Set as :${append}`);\n    return;\n  }\n  this.updateMeasurements();\n  this.updateScroller();\n  this.isPrefilling = true;\n  this.on( 'append', this.prefill );\n  this.once( 'error', this.stopPrefill );\n  this.once( 'last', this.stopPrefill );\n  this.prefill();\n};\n\nproto.prefill = function() {\n  let distance = this.getPrefillDistance();\n  this.isPrefilling = distance >= 0;\n  if ( this.isPrefilling ) {\n    this.log('prefill');\n    this.loadNextPage();\n  } else {\n    this.stopPrefill();\n  }\n};\n\nproto.getPrefillDistance = function() {\n  // element scroll\n  if ( this.options.elementScroll ) {\n    return this.scroller.clientHeight - this.scroller.scrollHeight;\n  }\n  // window\n  return this.windowHeight - this.element.clientHeight;\n};\n\nproto.stopPrefill = function() {\n  this.log('stopPrefill');\n  this.off( 'append', this.prefill );\n};\n\n// --------------------------  -------------------------- //\n\nreturn InfiniteScroll;\n\n} ) );\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}